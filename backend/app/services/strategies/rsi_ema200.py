"""
RSI + EMA200 Strategy
=====================
Mean reversion strategy with trend filter.

Rules:
1. EMA 200 defines bias (LONG above, SHORT below)
2. RSI < 30 = oversold (LONG signal)
3. RSI > 70 = overbought (SHORT signal)
4. ATR-based SL/TP for dynamic risk management
"""

from dataclasses import dataclass
from typing import Optional
import pandas as pd
import numpy as np
import logging

logger = logging.getLogger(__name__)


@dataclass
class RSISignal:
    """Signal generated by RSI + EMA200 strategy."""
    direction: str  # "LONG", "SHORT", "WAIT"
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 0.0
    reason: str = ""

    # Metadata
    rsi: Optional[float] = None
    ema_200: Optional[float] = None
    atr: Optional[float] = None

    def to_dict(self) -> dict:
        return {
            "direction": self.direction,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "confidence": self.confidence,
            "reason": self.reason,
            "rsi": self.rsi,
            "ema_200": self.ema_200,
            "atr": self.atr
        }


class RSIEMA200Strategy:
    """
    RSI + EMA200 Mean Reversion Strategy.

    Simple, robust, good for ranging and trending markets.
    """

    def __init__(
        self,
        rsi_period: int = 14,
        rsi_oversold: float = 30.0,
        rsi_overbought: float = 70.0,
        ema_period: int = 200,
        atr_period: int = 14,
        atr_sl_multiplier: float = 1.5,
        atr_tp_multiplier: float = 2.5,
        require_trend_alignment: bool = True
    ):
        """
        Initialize strategy.

        Args:
            rsi_period: RSI calculation period
            rsi_oversold: RSI level for oversold (buy signal)
            rsi_overbought: RSI level for overbought (sell signal)
            ema_period: EMA period for trend filter
            atr_period: ATR period for volatility
            atr_sl_multiplier: ATR multiplier for stop loss
            atr_tp_multiplier: ATR multiplier for take profit
            require_trend_alignment: If True, only trade with EMA200 trend
        """
        self.rsi_period = rsi_period
        self.rsi_oversold = rsi_oversold
        self.rsi_overbought = rsi_overbought
        self.ema_period = ema_period
        self.atr_period = atr_period
        self.atr_sl_multiplier = atr_sl_multiplier
        self.atr_tp_multiplier = atr_tp_multiplier
        self.require_trend_alignment = require_trend_alignment

        logger.info(
            f"RSIEMA200Strategy initialized: "
            f"RSI({rsi_period}) {rsi_oversold}/{rsi_overbought}, "
            f"EMA({ema_period}), ATR SL:{atr_sl_multiplier}x TP:{atr_tp_multiplier}x"
        )

    def calculate_rsi(self, df: pd.DataFrame) -> pd.Series:
        """Calculate RSI indicator."""
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.rsi_period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.rsi_period).mean()

        rs = gain / (loss + 0.0001)  # Avoid division by zero
        rsi = 100 - (100 / (1 + rs))
        return rsi

    def calculate_atr(self, df: pd.DataFrame) -> pd.Series:
        """Calculate ATR for dynamic SL/TP."""
        high_low = df['high'] - df['low']
        high_close = abs(df['high'] - df['close'].shift())
        low_close = abs(df['low'] - df['close'].shift())

        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        atr = true_range.rolling(window=self.atr_period).mean()
        return atr

    def calculate_ema(self, df: pd.DataFrame) -> pd.Series:
        """Calculate EMA 200."""
        return df['close'].ewm(span=self.ema_period, adjust=False).mean()

    def get_trend_bias(self, price: float, ema_200: float) -> str:
        """Determine trend bias based on EMA 200."""
        buffer = ema_200 * 0.001  # 0.1% buffer

        if price > ema_200 + buffer:
            return "BULLISH"
        elif price < ema_200 - buffer:
            return "BEARISH"
        return "NEUTRAL"

    def analyze(self, df: pd.DataFrame) -> RSISignal:
        """
        Analyze market and generate signal.

        Args:
            df: DataFrame with OHLC columns

        Returns:
            RSISignal with direction and levels
        """
        # Validate data
        min_periods = max(self.ema_period, self.rsi_period, self.atr_period) + 10
        if len(df) < min_periods:
            return RSISignal(
                direction="WAIT",
                reason=f"Insufficient data ({len(df)} < {min_periods})"
            )

        # Calculate indicators
        df = df.copy()
        df['rsi'] = self.calculate_rsi(df)
        df['ema_200'] = self.calculate_ema(df)
        df['atr'] = self.calculate_atr(df)

        current = df.iloc[-1]
        price = current['close']
        rsi = current['rsi']
        ema_200 = current['ema_200']
        atr = current['atr']

        if pd.isna(rsi) or pd.isna(ema_200) or pd.isna(atr):
            return RSISignal(
                direction="WAIT",
                reason="Indicators not ready"
            )

        # Get trend bias
        bias = self.get_trend_bias(price, ema_200)

        # Check for signals
        signal_direction = None
        reason = ""

        # LONG: RSI oversold + bullish bias (or no trend requirement)
        if rsi < self.rsi_oversold:
            if not self.require_trend_alignment or bias == "BULLISH":
                signal_direction = "LONG"
                reason = f"RSI oversold ({rsi:.1f}) + {bias} trend"
            else:
                return RSISignal(
                    direction="WAIT",
                    confidence=0.3,
                    reason=f"RSI oversold but {bias} bias - waiting",
                    rsi=round(rsi, 1),
                    ema_200=round(ema_200, 5),
                    atr=round(atr, 5)
                )

        # SHORT: RSI overbought + bearish bias
        elif rsi > self.rsi_overbought:
            if not self.require_trend_alignment or bias == "BEARISH":
                signal_direction = "SHORT"
                reason = f"RSI overbought ({rsi:.1f}) + {bias} trend"
            else:
                return RSISignal(
                    direction="WAIT",
                    confidence=0.3,
                    reason=f"RSI overbought but {bias} bias - waiting",
                    rsi=round(rsi, 1),
                    ema_200=round(ema_200, 5),
                    atr=round(atr, 5)
                )

        # No signal
        if not signal_direction:
            return RSISignal(
                direction="WAIT",
                reason=f"RSI neutral ({rsi:.1f})",
                rsi=round(rsi, 1),
                ema_200=round(ema_200, 5),
                atr=round(atr, 5)
            )

        # Calculate SL/TP based on ATR
        if signal_direction == "LONG":
            stop_loss = price - (atr * self.atr_sl_multiplier)
            take_profit = price + (atr * self.atr_tp_multiplier)
        else:  # SHORT
            stop_loss = price + (atr * self.atr_sl_multiplier)
            take_profit = price - (atr * self.atr_tp_multiplier)

        # Confidence based on RSI extremity
        if signal_direction == "LONG":
            confidence = 0.6 + (0.2 * (self.rsi_oversold - rsi) / self.rsi_oversold)
        else:
            confidence = 0.6 + (0.2 * (rsi - self.rsi_overbought) / (100 - self.rsi_overbought))

        confidence = min(0.9, max(0.6, confidence))

        logger.info(
            f"Signal: {signal_direction} | RSI: {rsi:.1f} | "
            f"Entry: {price:.5f} | SL: {stop_loss:.5f} | TP: {take_profit:.5f}"
        )

        return RSISignal(
            direction=signal_direction,
            entry_price=round(price, 5),
            stop_loss=round(stop_loss, 5),
            take_profit=round(take_profit, 5),
            confidence=round(confidence, 2),
            reason=reason,
            rsi=round(rsi, 1),
            ema_200=round(ema_200, 5),
            atr=round(atr, 5)
        )

    def generate_signal(self, df: pd.DataFrame) -> RSISignal:
        """Alias for analyze() - implements StrategyProtocol."""
        return self.analyze(df)
